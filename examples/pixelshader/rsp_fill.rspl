include "rsp_queue.inc"

#define TILE_W 16
#define TILE_H 16
#define TILE_NUM_PIXELS 256
#define TILE_NUM_BYTES 512
#define SMALL_NUM_PIXELS 64
#define SMALL_NUM_BYTES 128

#define TEX_NUM_ADDRESS_BITS 9
#define TEX_NUM_BLOCK_BITS 5 // 16 - TEX_NUM_ADDRESS_BITS
#define TEX_NUM_PIXELS 256
#define TEX_NUM_BYTES 512 // 2^TEX_NUM_ADDRESS_BITS

#define MASK_BLOCK_INDEX 0xfe00
#define MASK_BLOCK_OFFSET 0x1ff

#define RESULT_MISS 0xffff
#define KEY_EMPTY 0x7fff

#define CACHE_NUM_LINES 8
#define CACHE_LINE_NUM_BYTES 32
#define CACHE_LINE_SIZE_BITS 4
#define CACHE_SIZE_BYTES 256

#define MASK_TAG  0x0007fff0  // largest tag is 32767-1 so we can use vector ops
#define MASK_OFS  0x0000000f
#define MASK_BASE 0xfff80000

state {
  vec16 SCREEN_SIZE_VEC;
  u16 SCREEN_STRIDE;

  alignas(16)
  u16 TILE_BUFFER[TILE_NUM_PIXELS];
  alignas(16)
  u16 SMALL_BUFFER[SMALL_NUM_PIXELS];
  alignas(16)
  u16 ADDRESS_BUFFER[TILE_NUM_PIXELS];  
  alignas(16)  
  u16 TEXTURE_BUFFER[TEX_NUM_PIXELS];  
  alignas(16)
  u16 CACHE[CACHE_LINE_NUM_BYTES];

  vec16 TEMP_VEC;
  vec16 LANE_INDS = {7,6,5,4,3,2,1,0};
  vec16 TEST_KEYS = {KEY_EMPTY,KEY_EMPTY,KEY_EMPTY,KEY_EMPTY,KEY_EMPTY,KEY_EMPTY,KEY_EMPTY,KEY_EMPTY};
  vec16 TEST_VALUES = {0,0,0,0,0,0,0,0};
  vec16 ADDRESS_OFFSET_VECTOR;
  u32 TEXTURE_BASE_ADDRESS; //RDRAM texture data address
  u16 LAST_KEY = {KEY_EMPTY};
  u16 LAST_SLOT = {7};
  
  u32 DATA_START = {0};
  u16 TEX_ACTIVE_BLOCK_INDEX;
  u32 NUM_CACHE_READS;
  alignas(16)
  vec16 CONSTANT_COLOR_BLUE = {0x3e,0x3e,0x3e,0x3e,0x3e,0x3e,0x3e,0x3e};
  alignas(16)
  vec16 CONSTANT_COLOR_GREEN = {0x7C0,0x7C0,0x7C0,0x7C0,0x7C0,0x7C0,0x7C0,0x7C0};
  alignas(16)
  vec16 CONSTANT_COLOR_RED = { 0xF800, 0xF800, 0xF800, 0xF800, 0xF800, 0xF800, 0xF800, 0xF800};
  alignas(32)
  vec32 PER_LANE_OFFSET = {0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0};
  u32 TEX_MATRIX[4];
  u32 TEX_OFFSET[2];
}

command<0> FillCmd_SetScreenSize(u32 unused, u32 sizeXY, u32 stride)
{
  u32 sizeX = sizeXY >> 16;
  u32 sizeY = sizeXY & 0xFFFF;

  vec16 screenSize;
  screenSize.x = sizeX;
  screenSize.y = sizeY;
  store(screenSize, SCREEN_SIZE_VEC);
  store(stride, SCREEN_STRIDE);
  //printf("size: %u, stride: %u\n", screenSize, stride);
}

//   t0: transfer size as width/height (use DMA_SIZE macro)
//   t1: pitch (ignored if height==1)
//   s0: RDRAM address
//   s4: DMEM address. After DMA, updated with unalignment
function DMAOut(u32<$s4> dmem, u32<$s0> rdram, u32<$t0> size, u32<$t1> pitch);
function DMAIn(u32<$s4> dmem, u32<$s0> rdram, u32<$t0> size, u32<$t1> pitch);

command<1> FillCmd_DrawConstant(u32 unused, u32 startAddress, u32 color)
{
    // 16x16 pixel tiles with 16 bits per pixel
    u32<$s0> dest = startAddress;
    u32<$s4> src = TILE_BUFFER;
    u32<$t0> size;
    asm("li $t0, DMA_SIZE(32,16)");
    u32<$t1> pitch = load(SCREEN_STRIDE);
    
    // printf("startAddress: 0x%x, color: 0x%x\n", startAddress, color);

    vec16 rgb555 = color;
    u32 out = TILE_BUFFER;
    u16 rows = TILE_H;
    
    while (rows > 0) {
         store(rgb555, out, 0);
         store(rgb555, out, 16);
         out = out + 32;
         rows = rows - 1;
    }

    // // printf("size: 0x%x, pitch: 0x%x\n", size, pitch);

    // // asm("li $t0, DMA_SIZE3(32,16,1280)");
    // // asm("li $t1, 1280");
    
    DMAOut(src, dest, size, pitch);
}

// 0, dst_address, src_address, dst->stride, src->stride, bias
command<2> FillCmd_Downsample(u32 biasIn, u32 dstAddress, u32 srcAddress, u32 dstSrcStride)
{
    u32<$s0> dest = srcAddress;
    u32<$s4> src = TILE_BUFFER;
    u32<$t0> size;
    asm("li $t0, DMA_SIZE(32,16)");
    u32<$t1> pitch = dstSrcStride;
    pitch &= 0x0000ffff;

    printf("In:  src: 0x%x, dest: 0x%x, pitch: %v, size: %v\n", src, dest, pitch, size);
    u32 bias = biasIn & 0xff;
    @Barrier("read") DMAIn(src, dest, size, pitch);
    
    u16 rows = 8;
    u32 in = TILE_BUFFER;
    u32 out = SMALL_BUFFER;
    u32 color = 0x8fff;
    vec16 v = color;


    while (rows > 0) {
         //@Barrier("read") v = load(in);
         printf("[%u] %v\n", rows, v);
         @Barrier("write") store(v, out, 0);
         // @Barrier("write") v = load(out);
         // printf("[%u] %v after\n", rows, v);
         out = out + 16;
         in = in + 32;
         rows = rows - 1;
    }

    dest = dstAddress;
    src = SMALL_BUFFER;
    asm("li $t0, DMA_SIZE(16,8)");
    pitch = dstSrcStride;
    pitch >>= 16;
    printf("Out: src: 0x%x, dest: 0x%x, pitch: %v, size: %v\n", src, dest, pitch, size);
    @Barrier("write") DMAOut(src, dest, size, pitch);
}


macro dotXYZW_u16(vec16 res, vec16 a, vec16 b)
{
  res:sint = a * b;
  vec16 tmp:sint = res + res.yyyyYYYY;
  tmp:sint += res.zzzzZZZZ;
  tmp:sint += res.wwwwWWWW;
  // then sum X to x, so we get a sum of the two products
  res:sint = tmp + tmp.X;
  // result is in res.x
}

macro sumXYZW_u16(vec16 res, vec16 a)
{
  res:sint = a;
  vec16 tmp:sint = res + res.yyyyYYYY;
  tmp:sint += res.zzzzZZZZ;
  tmp:sint += res.wwwwWWWW;
  res:sint = tmp + tmp.X;
  // result is in res.x
}

macro keyLookup(vec16 keys, vec16 values, u16 queryScalar, u16 output)
{
  vec16 query = queryScalar;
  
  vec16 masked;
  {
    //vec16 values = load(TEST_ADDR);
    vec16 zeros = 0;
    masked = keys == query ? values : zeros;
    printf("keys:   %v\n", keys);
    printf("query:  %v\n", query);
    printf("values: %v\n", values);
    printf("masked: %v\n", masked);
  }

  u16 vcc = get_vcc();
  vcc = vcc & 0xff;
  printf("vcc: %v\n", vcc);
  if (vcc != 0) {
    vec16 found;
    sumXYZW_u16(found, masked);
    // found a hit on some lane
    // printf("addr:  %v\n", addr);
    output = found.x;
  } else {
    printf("cache miss\n");
    output = RESULT_MISS;
  }
}

command<3> FillCmd_CacheTest(u32 _, u32 dataAddress)
{
  u32<$s0> rdram_addr;
  u32<$s4> dmem_addr;
    
  vec16 keys = load(TEST_KEYS);
  vec16 values = load(TEST_VALUES);
  
  //TODO split rdram into data_table + 20-bit offset
  rdram_addr = dataAddress;
  printf("\n");
  printf("rdram_addr: %v\n", rdram_addr);
  
  u16 tag = rdram_addr & MASK_TAG;
  u16 ofs = rdram_addr & MASK_OFS;
  tag = tag >> CACHE_LINE_SIZE_BITS;
  rdram_addr = rdram_addr & MASK_BASE;
  store(rdram_addr, DATA_START);
  
  printf("tag:   %v\n", tag);
  printf("ofs:   %v\n", ofs);
  printf("start: %v\n", rdram_addr);
 
  //u16 ptr = 456;
  u16<$t1> addr = 1;
  keyLookup(keys, values, tag, addr);
  printf("lookup found: %v\n", addr);
  
  
  if (addr == RESULT_MISS) {
    // fetch
    // pick a cache slot. round robin for now
    u16 slot = load(LAST_SLOT);
    slot += 1;
    slot = slot & 0x7;
    store(slot, LAST_SLOT);
    
    printf("slot: %v\n", slot);
    
    dmem_addr = slot;
    // load data from RDRAM to DMEM to matching cache line
    dmem_addr <<= CACHE_LINE_SIZE_BITS;
    dmem_addr += CACHE;
    printf("dmem_addr: %v\n", dmem_addr);
    
    // u32<$s0> addr_ram;
    // u32<$s4> addr_dmem = VARIABLE;
    // dma_in(addr_dmem, addr_ram, 32);
    // u32 addr_dmem_end = addr_dmem + 32;
    
    rdram_addr = load(DATA_START);
    tag <<= CACHE_LINE_SIZE_BITS;
    rdram_addr |= tag;
    tag >>= CACHE_LINE_SIZE_BITS;
    printf("dma_in(%v, %v, ...)\n", dmem_addr, rdram_addr);
    dma_in(dmem_addr, rdram_addr, CACHE_LINE_NUM_BYTES);

    // update the key
    slot *= 2; // slot is a 16-bit word index
    u16 tempaddr = TEST_KEYS;
    tempaddr += slot;
    store(tag, tempaddr);
    
     // update 'addr' in memory and for below
    addr = dmem_addr;
    tempaddr = TEST_VALUES;
    tempaddr += slot;
    store(addr, tempaddr);
    
    // update the "last active"
    store(tag, LAST_KEY);
    
  } else {
    printf("cache hit!\n");
  }
  
  // load the word from DMEM
  {
    addr += ofs;
    printf("addr: %v, (ofs: %v)\n", addr, ofs);
    u16 word = load(addr);
    printf("word: %v\n", word);
    addr -= ofs;
  }
  
  {
    u16 counter=16;
    printf("data:\n");
    while (counter > 0) {
      u16 data = load(addr);
      printf(" [%v] = %v\n", addr, data);
      counter = counter - 1;
      addr += 2;
    }
    printf("\n");
    
  }
}

macro gather8(vec16 dest, vec16 dmemAddresses)
{
  store(dmemAddresses, TEMP_VEC);

  // TODO: is read-after-write to DMEM honored here?
  u16 i0 = load(TEMP_VEC, 0);
  u16 i1 = load(TEMP_VEC, 2);
  u16 i2 = load(TEMP_VEC, 4);
  u16 i3 = load(TEMP_VEC, 6);
  u16 i4 = load(TEMP_VEC, 8);
  u16 i5 = load(TEMP_VEC, 10);
  u16 i6 = load(TEMP_VEC, 12);
  u16 i7 = load(TEMP_VEC, 14);
  
  dest.x = load(i0);
  dest.y = load(i1);
  dest.z = load(i2);
  dest.w = load(i3);
  dest.X = load(i4);
  dest.Y = load(i5);
  dest.Z = load(i6);
  dest.W = load(i7);
}

command<4> FillCmd_GatherTest(u32 _, u32 dataAddress)
{
  u32 rdram = dataAddress;
  // dma_in(ADDRESS_BUFFER, rdram, TILE_NUM_BYTES);
  vec16 values;
  vec16 addr;
  
  u32 counter=32;
  u32 dmemAddressSource = ADDRESS_BUFFER;
  u32<$s4> dmemDest = TILE_BUFFER;
  
  vec16 ofs = load(ADDRESS_OFFSET_VECTOR);
  
  u32 baseAddress = load(TEXTURE_BASE_ADDRESS);
  u32 numCacheReads = 0; // load(NUM_CACHE_READS);
  // printf("texture base address: 0x%x\n", baseAddress);

  // vec32 = base, offset
  // actually we have only 12-bit offsets possible
  // --> 64k textures? assume word alignment --> 128k
  // 128k bytes = 181x181 RGB555 texture
  // maps to 32 4k textures, maybe enough for a scene?
  // still need a "base" address for DMEM loads

  vec16 indexMask;
  indexMask.x = MASK_BLOCK_INDEX;
  indexMask = indexMask.x;
  
  vec16 activeIndex;
  activeIndex.x = load(TEX_ACTIVE_BLOCK_INDEX).x;
  activeIndex = activeIndex.x;
  
  vec16 newValues;

  while (counter > 0) {
    u32 lanesLoaded = 0xffffff00;
    values = load(CONSTANT_COLOR_BLUE);
    
    tryAgain:
    {
      u16 indx = TEX_ACTIVE_BLOCK_INDEX;
      // printf("[%d] lanesLoaded: 0x%x, block: %v\n", counter, lanesLoaded, indx);
    }
    if (lanesLoaded == 0xffffffff) {
      goto writePixels;
    }
    //printf("counter: %v\n", counter);
    addr:sint = load(dmemAddressSource);
    //printf("dmemAddressSource: %v, addr1: %v\n", dmemAddressSource, addr);
    {
      u16 test = addr.x;
      //printf("addr.x = 0x%x\n", test);
    }
    
    vec16 blockInds;
    blockInds = addr & indexMask;
    {
      vec16 unused = blockInds == activeIndex;
    }
    u32 vcc = get_vcc();
    vcc &= 0xff;
    // printf("addr: %v\nblck: %v\n", addr, blockInds);
    // printf("actv: %v\n", activeIndex);
    // printf("resident vcc: 0x%x\n", vcc);
    
    lanesLoaded |= vcc;

    {
      addr:sint -= blockInds; // addr is now relative to block start
      addr:sint = addr:sint + ofs:sint; // addr is now in DMEM space
      
      @Barrier("values") gather8(newValues, addr);
      //printf("newValues: %v\n", newValues);
      //printf("values1:   %v\n", values);
      @Barrier("values") values = select(newValues, values);
      //printf("values2:   %v\n", values); // FIXME breaks without this print
      //printf("lanesLoaded: 0x%x\n", lanesLoaded);
      if (lanesLoaded == 0xffffffff) {
        goto writePixels;
      }
      
      // find the next block index because we have some lanes left
      // 
      store(blockInds, TEMP_VEC);
      u32 lanesInProgress = ~lanesLoaded;
      // printf("loaded: 0x%x, in progress: 0x%x\n", lanesLoaded, lanesInProgress);
      u16 bitsLeft=8;
      u16 nextBlock = 0xffff;
      while (bitsLeft > 0) {
        u32 wip=lanesInProgress & 1;
        //printf("bitsLeft: %v, lanesInProgress: 0x%x, wip: %v\n", bitsLeft, lanesInProgress, wip);
        if (wip) {
          // load a new block
          u16 idx = 8;
          idx -= bitsLeft;
          idx *= 2;
          nextBlock = load(idx, TEMP_VEC);
          //printf("blockInds: %v\n", blockInds);
          //printf("idx: %v, nextBlock: 0x%x\n", idx, nextBlock);
          goto nextBlockFound;
        }
        lanesInProgress >>= 1;
        bitsLeft = bitsLeft - 1;
      }
      nextBlockFound:
      // printf("nextBlock: 0x%x\n", nextBlock);
      if (nextBlock == 0xffff) {
        printf("ERROR: next block not found!\n");
      }
      // printf("rdram = ");
      rdram = load(TEXTURE_BASE_ADDRESS);
      // printf("0x%x + 0x%x = ", rdram, nextBlock);
      rdram += nextBlock;
      // printf("0x%x\n", rdram);
      u32<$t2> t2;
      u32<$t3> at_temp;
      u32 t2temp = t2;
      // asm("or $t3, $zero, $at");
      //u32 attemp = at;
      u32 dmem_reg = TEXTURE_BUFFER;
      u32 num_bytes= TEX_NUM_BYTES;
      // printf("dma_in(0x%x, 0x%x, %v)\n", dmem_reg, rdram, num_bytes);
      u32 dmemDestTemp = dmemDest;
      dma_in(TEXTURE_BUFFER, rdram, TEX_NUM_BYTES);
      numCacheReads += 1;
      store(numCacheReads, NUM_CACHE_READS);
      
      // asm("or $at, $zero, $t3");
      
      dmemDest = dmemDestTemp;
      t2 = t2temp;
      //at = attemp;
      @Barrier("active") store(nextBlock, TEX_ACTIVE_BLOCK_INDEX);
      @Barrier("active") u16 testNextBlock = load(TEX_ACTIVE_BLOCK_INDEX);
      // printf("nextBlock: 0x%x, loaded next block: 0x%x\n", nextBlock, testNextBlock);
      {
        activeIndex.x = nextBlock;
        activeIndex = activeIndex.x;
      }
      // printf("rdram: 0x%x\nactiveIndex: %v\n", rdram, activeIndex);
      
      // u32 index = 0;
      // while (index < 16) {
      //   u16 value = load(index, TEXTURE_BUFFER);
      //   printf("TEXTURE_BUFFER[%v] = 0x%x\n", index, value);
      //   index = index + 2;
      // }
      goto tryAgain;
    }
    
    // if (vcc == 0x0f) {
    //   values = load(CONSTANT_COLOR_GREEN);
    // }
    
    writePixels:
    // {
    // u32 temp = TILE_BUFFER;
    // printf("Writing values=%v to DMEM at 0x%x (TILE_BUFFER=0x%x)\n", values, dmemDest, temp);
    // }
    
    // Cache read count debug viz
    // {
    //   u16 color = numCacheReads;
    //   //color ^= 0x0f;
    //   color *= 8;
    //   color *= 2;
    //   //color += numCacheReads;
    //   values.x = color;
    //   values = values.x;
    // }
    
    @Barrier("values") store(values, dmemDest);
    dmemAddressSource = dmemAddressSource + 16;
    dmemDest = dmemDest + 16;
    counter = counter - 1;
  }
}

command<5> FillCmd_LoadTexture(u32 _, u32 dataAddress)
{
  u32 rdram = dataAddress;
  store(rdram, TEXTURE_BASE_ADDRESS);
  
  //u32 block = rdram & MASK_BLOCK_INDEX;
  u32 block = 0xffffffff;
  store(block, TEX_ACTIVE_BLOCK_INDEX);

  //dma_in(TEXTURE_BUFFER, rdram, TEX_NUM_BYTES);
  vec16 ofs;
  u16 from = TEXTURE_BUFFER;
  ofs.x = from;
  ofs = ofs.x;
  store(ofs, ADDRESS_OFFSET_VECTOR);
  
  u32 zero = 0;
  store(zero, NUM_CACHE_READS);
}

  
command<6> FillCmd_StoreTile(u32 _, u32 dataAddress, u32 stride)
{
  u32<$s4> dmem = TILE_BUFFER;
  u32<$s0> rdram = dataAddress;
  u32<$t1> pitch = stride;
  u32<$t0> transferSize;
  
  // Transfer a block of 16x16 RGB555 pixels
  asm("li $t0, DMA_SIZE(32,16)"); // macro defined in libdragon's rsp.inc

  DMAOut(dmem, rdram, transferSize, pitch);
}

command<7> FillCmd_StoreTexture(u32 _, u32 dataAddress)
{
  u32 rdram = dataAddress;
  dma_out(TEXTURE_BUFFER, rdram, TEX_NUM_BYTES);
}

command<8> FillCmd_ComputeTexCoords(u32 _, u32 topLeftCoords, u32 time)
{
  
  u32 cx = topLeftCoords & 0xffff;
  u32 cy = topLeftCoords >> 16;
  cx <<= 16;
  cy <<= 16;
  
  vec32 vxRow; // reset at row start
  vec32 vy;
  vec16 ones;
  ones.x = 1;
  ones = ones.x;

  vec16 eights;
  eights.x = 8;
  eights = eights.x;
  
  vec32 vxofs;
  vec32 vyofs;
  
  //vec32 vc00;
  //vec32 vc00;
  //vec32 vc00;
  //vec32 vc00;

  {
    s32 c00 = load(TEX_MATRIX, 0);
    s32 c01 = load(TEX_MATRIX, 4);
    s32 c10 = load(TEX_MATRIX, 8);
    s32 c11 = load(TEX_MATRIX, 12);
    s32 xofs = load(TEX_OFFSET, 0);
    s32 yofs = load(TEX_OFFSET, 4);
  
    printf("ComputeTexCoords:\n");
    printf("Tex matrix:\n");
    printf("[ %v %v ]\n", c00, c10);
    printf("[ %v %v ]\n", c01, c11);
    printf("c:   (%v, %v)\n", cx, cy);
    printf("ofs: (%v, %v)\n", xofs, yofs);
    
    // printf("dx, dy: (%d, %d)\n", dx, dy);
    vxofs = xofs;
    vyofs = yofs;

    vxRow.x = cx;
    vxRow = vxRow.x;
    vec32 stepX = load(PER_LANE_OFFSET);
    vxRow += stepX;
    
    vy.x = cy;
    vy = vy.x;
  }
  
  printf("vxRow: %v\n", vxRow);
  printf("vy: %v\n", vy);

  vec16 texCoordMask;
  texCoordMask.x = 0x7f;
  texCoordMask = texCoordMask.x;

  vec32 vx = vxRow;
 
  //vec32 xrow = yrow;

  u32 counterY = 16;
  u32 dmemAddressDest = ADDRESS_BUFFER;
  while (counterY > 0) {
    u32 counterX = 2;
    vx = vxRow;
    while (counterX > 0) {
      vec32 px = vx; //vxofs;
      vec32 py = vy; //vyofs;
      
      // px = 
      
      vec16 texx = px:sint;
      vec16 texy = py:sint;
      texx &= texCoordMask;
      texy &= texCoordMask;
      
      // printf("vx:  %v%v\n", vx);
      // printf("vy:  %v%v\n", vy);
      // printf("tx:  %v%v\n", texx);
      // printf("ty:  %v%v\n", texy);
      
      vec16 addr = texy;
      addr *= 128;
      addr += texx;
      addr *= 2;
      
      store(addr, dmemAddressDest);
      
      vx:sint += eights;
      counterX -= 1;  
      dmemAddressDest += 16;
    }
  
    vy:sint += ones;
    counterY -= 1;
  }

  /*
  vec16 perLaneOfsX = load(PER_LANE_OFFSET);
  vec16 one;
  one.x = 1;
  one = one.x;
  
  vec16 eight;
  eight.x = 8;
  eight = eight.x;
  
  vec16 vxRow = cx;
  vxRow += perLaneOfsX;
  vec16 vx = vxRow;
  vec16 vy = cy;
  
  vec16 times;
  times.x = time;
  times = times.x;
  // printf("c=(%v,%v), times=%v\n", cx, cy, times);
  // printf("per lane ofs x: %v\n", perLaneOfsX);
  // printf("per lane ofs y: %v\n", one);
  // printf("vx: %v\n", vx);
  // printf("vy: %v\n", vy);
  
  vec16 texCoordMask;
  texCoordMask.x = 0x7f;
  texCoordMask = texCoordMask.x;
  vec16 texSize;
  texSize.x = 128;
  texSize = texSize.x;
  vec16 toFixed;
  toFixed.x = 0x010; // s11.4 fixed point
  toFixed = toFixed.x;
  
  // FIXME 7.8 fixed point doesn't work with multiplication
  // FIXME 7.8 fixed point doesn't have enough range
  
  u32 counterY = 16;
  u32 dmemAddressDest = ADDRESS_BUFFER;
  while (counterY > 0) {
    u32 counterX = 2;
    vx = vxRow;
    while (counterX > 0) {
      vec16 xtile = vx;
      vec16 ytile = vy;
      
      xtile *= toFixed;
      ytile *= toFixed;
      
      // printf("xtile: %v\n", xtile);
      // printf("vc00: %v\n", vc00);
      
      //TODO use muladd +*
      vec16 ax:sint = vc00 * xtile;
      ax >>= 4;
      vec16 by = vc10 * ytile;
      by >>= 4;
      vec16 cx = vc01 * xtile;
      cx >>= 4;
      vec16 dy = vc11 * ytile;
      dy >>= 4;
      
      // printf("ax: %v\n", ax);

      xtile = ax;
      xtile += by;
      ytile = cx;
      ytile += dy;
      
      xtile += vxofs;
      ytile += vyofs;
      
      xtile >>= 4;
      ytile >>= 4;
      
      xtile &= texCoordMask;
      ytile &= texCoordMask;
      
      // printf("tiled: (%v), (%v)\n", xtile, ytile);
      
      vec16 addr = ytile;
      addr *= texSize;
      addr += xtile;
      addr *= 2;
      
      store(addr, dmemAddressDest);
      
      vx += eight;
      counterX -= 1;  
      dmemAddressDest += 16;
    }
  
    vy += one;
    counterY -= 1;
  }
  */
}

command<9> FillCmd_LoadTexMatrix(u32 _, u32 matrixRdram, u32 inx, u32 iny)
{
  u32 xofs = inx;
  u32 yofs = iny;
  dma_in(TEX_MATRIX, matrixRdram);
  printf("Tex matrix:\n");
  s32 c00 = load(TEX_MATRIX, 0);
  s32 c01 = load(TEX_MATRIX, 4);
  s32 c10 = load(TEX_MATRIX, 8);
  s32 c11 = load(TEX_MATRIX, 12);
  printf("[ %f %f ]\n", c00, c10);
  printf("[ %f %f ]\n", c01, c11);
  printf("ofs: (%f %f)\n", xofs, yofs);
  store(xofs, TEX_OFFSET, 0);
  store(xofs, TEX_OFFSET, 4);
}
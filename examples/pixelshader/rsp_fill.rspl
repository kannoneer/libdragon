include "rsp_queue.inc"

#define TILE_W 16
#define TILE_H 16
#define TILE_NUM_PIXELS 256
#define TILE_NUM_BYTES 512
#define SMALL_NUM_PIXELS 64
#define SMALL_NUM_BYTES 128

#define TEX_NUM_ADDRESS_BITS 9
#define TEX_NUM_BLOCK_BITS 5 // 16 - TEX_NUM_ADDRESS_BITS
#define TEX_NUM_PIXELS 256
#define TEX_NUM_BYTES 512 // 2^TEX_NUM_ADDRESS_BITS

#define MASK_BLOCK_INDEX 0xfe00
#define MASK_BLOCK_OFFSET 0x1ff

#define RESULT_MISS 0xffff
#define KEY_EMPTY 0x7fff

#define CACHE_NUM_LINES 8
#define CACHE_LINE_NUM_BYTES 32
#define CACHE_LINE_SIZE_BITS 4
#define CACHE_SIZE_BYTES 256

#define MASK_TAG  0x0007fff0  // largest tag is 32767-1 so we can use vector ops
#define MASK_OFS  0x0000000f
#define MASK_BASE 0xfff80000

state {
  vec16 SCREEN_SIZE_VEC;
  u16 SCREEN_STRIDE;

  alignas(16)
  u16 TILE_BUFFER[TILE_NUM_PIXELS];
  alignas(16)
  u16 SMALL_BUFFER[SMALL_NUM_PIXELS];
  alignas(16)
  u16 ADDRESS_BUFFER[TILE_NUM_PIXELS];  
  
  alignas(16)  
  u16 TEXTURE_BUFFER[TEX_NUM_PIXELS];  
  
  alignas(16)
  u16 CACHE[CACHE_LINE_NUM_BYTES];
  alignas(4)
  vec16 TEMP_VEC;
  alignas(4)
  vec16 LANE_INDS = {7,6,5,4,3,2,1,0};
  alignas(4)
  vec16 TEST_KEYS = {KEY_EMPTY,KEY_EMPTY,KEY_EMPTY,KEY_EMPTY,KEY_EMPTY,KEY_EMPTY,KEY_EMPTY,KEY_EMPTY};
  alignas(4)
  vec16 TEST_VALUES = {0,0,0,0,0,0,0,0};
  alignas(4)
  vec16 ADDRESS_OFFSET_VECTOR;
  alignas(4)
  u32 TEXTURE_BASE_ADDRESS; //RDRAM texture data address
  u16 LAST_KEY = {KEY_EMPTY};
  u16 LAST_SLOT = {7};
  
  u32 DATA_START = {0};
  u16 TEX_ACTIVE_BLOCK_INDEX;
  alignas(4)
  vec16 CONSTANT_COLOR_BLUE = {0x3e,0x3e,0x3e,0x3e,0x3e,0x3e,0x3e,0x3e};
  vec16 CONSTANT_COLOR_GREEN = {0x7C0,0x7C0,0x7C0,0x7C0,0x7C0,0x7C0,0x7C0,0x7C0};
  vec16 CONSTANT_COLOR_RED = { 0xF800, 0xF800, 0xF800, 0xF800, 0xF800, 0xF800, 0xF800, 0xF800};
  
}

command<0> FillCmd_SetScreenSize(u32 unused, u32 sizeXY, u32 stride)
{
  u32 sizeX = sizeXY >> 16;
  u32 sizeY = sizeXY & 0xFFFF;

  vec16 screenSize;
  screenSize.x = sizeX;
  screenSize.y = sizeY;
  store(screenSize, SCREEN_SIZE_VEC);
  store(stride, SCREEN_STRIDE);
  //printf("size: %u, stride: %u\n", screenSize, stride);
}

//   t0: transfer size as width/height (use DMA_SIZE macro)
//   t1: pitch (ignored if height==1)
//   s0: RDRAM address
//   s4: DMEM address. After DMA, updated with unalignment
function DMAOut(u32<$s4> dmem, u32<$s0> rdram, u32<$t0> size, u32<$t1> pitch);
function DMAIn(u32<$s4> dmem, u32<$s0> rdram, u32<$t0> size, u32<$t1> pitch);

command<1> FillCmd_DrawConstant(u32 unused, u32 startAddress, u32 color)
{
    // 16x16 pixel tiles with 16 bits per pixel
    u32<$s0> dest = startAddress;
    u32<$s4> src = TILE_BUFFER;
    u32<$t0> size;
    asm("li $t0, DMA_SIZE(32,16)");
    u32<$t1> pitch = load(SCREEN_STRIDE);
    
    // printf("startAddress: 0x%x, color: 0x%x\n", startAddress, color);

    vec16 rgb555 = color;
    u32 out = TILE_BUFFER;
    u16 rows = TILE_H;
    
    while (rows > 0) {
         store(rgb555, out, 0);
         store(rgb555, out, 16);
         out = out + 32;
         rows = rows - 1;
    }

    // // printf("size: 0x%x, pitch: 0x%x\n", size, pitch);

    // // asm("li $t0, DMA_SIZE3(32,16,1280)");
    // // asm("li $t1, 1280");
    
    DMAOut(src, dest, size, pitch);
}

// 0, dst_address, src_address, dst->stride, src->stride, bias
command<2> FillCmd_Downsample(u32 biasIn, u32 dstAddress, u32 srcAddress, u32 dstSrcStride)
{
    u32<$s0> dest = srcAddress;
    u32<$s4> src = TILE_BUFFER;
    u32<$t0> size;
    asm("li $t0, DMA_SIZE(32,16)");
    u32<$t1> pitch = dstSrcStride;
    pitch &= 0x0000ffff;

    printf("In:  src: 0x%x, dest: 0x%x, pitch: %v, size: %v\n", src, dest, pitch, size);
    u32 bias = biasIn & 0xff;
    @Barrier("read") DMAIn(src, dest, size, pitch);
    
    u16 rows = 8;
    u32 in = TILE_BUFFER;
    u32 out = SMALL_BUFFER;
    u32 color = 0x8fff;
    vec16 v = color;


    while (rows > 0) {
         //@Barrier("read") v = load(in);
         printf("[%u] %v\n", rows, v);
         @Barrier("write") store(v, out, 0);
         // @Barrier("write") v = load(out);
         // printf("[%u] %v after\n", rows, v);
         out = out + 16;
         in = in + 32;
         rows = rows - 1;
    }

    dest = dstAddress;
    src = SMALL_BUFFER;
    asm("li $t0, DMA_SIZE(16,8)");
    pitch = dstSrcStride;
    pitch >>= 16;
    printf("Out: src: 0x%x, dest: 0x%x, pitch: %v, size: %v\n", src, dest, pitch, size);
    @Barrier("write") DMAOut(src, dest, size, pitch);
}


macro dotXYZW_u16(vec16 res, vec16 a, vec16 b)
{
  res:sint = a * b;
  vec16 tmp:sint = res + res.yyyyYYYY;
  tmp:sint += res.zzzzZZZZ;
  tmp:sint += res.wwwwWWWW;
  // then sum X to x, so we get a sum of the two products
  res:sint = tmp + tmp.X;
  // result is in res.x
}

macro sumXYZW_u16(vec16 res, vec16 a)
{
  res:sint = a;
  vec16 tmp:sint = res + res.yyyyYYYY;
  tmp:sint += res.zzzzZZZZ;
  tmp:sint += res.wwwwWWWW;
  res:sint = tmp + tmp.X;
  // result is in res.x
}

macro keyLookup(vec16 keys, vec16 values, u16 queryScalar, u16 output)
{
  vec16 query = queryScalar;
  
  vec16 masked;
  {
    //vec16 values = load(TEST_ADDR);
    vec16 zeros = 0;
    masked = keys == query ? values : zeros;
    printf("keys:   %v\n", keys);
    printf("query:  %v\n", query);
    printf("values: %v\n", values);
    printf("masked: %v\n", masked);
  }

  u16 vcc = get_vcc();
  vcc = vcc & 0xff;
  printf("vcc: %v\n", vcc);
  if (vcc != 0) {
    vec16 found;
    sumXYZW_u16(found, masked);
    // found a hit on some lane
    // printf("addr:  %v\n", addr);
    output = found.x;
  } else {
    printf("cache miss\n");
    output = RESULT_MISS;
  }
}

command<3> FillCmd_CacheTest(u32 _, u32 dataAddress)
{
  u32<$s0> rdram_addr;
  u32<$s4> dmem_addr;
    
  vec16 keys = load(TEST_KEYS);
  vec16 values = load(TEST_VALUES);
  
  //TODO split rdram into data_table + 20-bit offset
  rdram_addr = dataAddress;
  printf("\n");
  printf("rdram_addr: %v\n", rdram_addr);
  
  u16 tag = rdram_addr & MASK_TAG;
  u16 ofs = rdram_addr & MASK_OFS;
  tag = tag >> CACHE_LINE_SIZE_BITS;
  rdram_addr = rdram_addr & MASK_BASE;
  store(rdram_addr, DATA_START);
  
  printf("tag:   %v\n", tag);
  printf("ofs:   %v\n", ofs);
  printf("start: %v\n", rdram_addr);
 
  //u16 ptr = 456;
  u16<$t1> addr = 1;
  keyLookup(keys, values, tag, addr);
  printf("lookup found: %v\n", addr);
  
  
  if (addr == RESULT_MISS) {
    // fetch
    // pick a cache slot. round robin for now
    u16 slot = load(LAST_SLOT);
    slot += 1;
    slot = slot & 0x7;
    store(slot, LAST_SLOT);
    
    printf("slot: %v\n", slot);
    
    dmem_addr = slot;
    // load data from RDRAM to DMEM to matching cache line
    dmem_addr <<= CACHE_LINE_SIZE_BITS;
    dmem_addr += CACHE;
    printf("dmem_addr: %v\n", dmem_addr);
    
    // u32<$s0> addr_ram;
    // u32<$s4> addr_dmem = VARIABLE;
    // dma_in(addr_dmem, addr_ram, 32);
    // u32 addr_dmem_end = addr_dmem + 32;
    
    rdram_addr = load(DATA_START);
    tag <<= CACHE_LINE_SIZE_BITS;
    rdram_addr |= tag;
    tag >>= CACHE_LINE_SIZE_BITS;
    printf("dma_in(%v, %v, ...)\n", dmem_addr, rdram_addr);
    dma_in(dmem_addr, rdram_addr, CACHE_LINE_NUM_BYTES);

    // update the key
    slot *= 2; // slot is a 16-bit word index
    u16 tempaddr = TEST_KEYS;
    tempaddr += slot;
    store(tag, tempaddr);
    
     // update 'addr' in memory and for below
    addr = dmem_addr;
    tempaddr = TEST_VALUES;
    tempaddr += slot;
    store(addr, tempaddr);
    
    // update the "last active"
    store(tag, LAST_KEY);
    
  } else {
    printf("cache hit!\n");
  }
  
  // load the word from DMEM
  {
    addr += ofs;
    printf("addr: %v, (ofs: %v)\n", addr, ofs);
    u16 word = load(addr);
    printf("word: %v\n", word);
    addr -= ofs;
  }
  
  {
    u16 counter=16;
    printf("data:\n");
    while (counter > 0) {
      u16 data = load(addr);
      printf(" [%v] = %v\n", addr, data);
      counter = counter - 1;
      addr += 2;
    }
    printf("\n");
    
  }
}

macro gather8(vec16 dest, vec16 dmemAddresses)
{
  store(dmemAddresses, TEMP_VEC);

  // TODO: is read-after-write to DMEM honored here?
  u16 i0 = load(TEMP_VEC, 0);
  u16 i1 = load(TEMP_VEC, 2);
  u16 i2 = load(TEMP_VEC, 4);
  u16 i3 = load(TEMP_VEC, 6);
  u16 i4 = load(TEMP_VEC, 8);
  u16 i5 = load(TEMP_VEC, 10);
  u16 i6 = load(TEMP_VEC, 12);
  u16 i7 = load(TEMP_VEC, 14);
  
  dest.x = load(i0);
  dest.y = load(i1);
  dest.z = load(i2);
  dest.w = load(i3);
  dest.X = load(i4);
  dest.Y = load(i5);
  dest.Z = load(i6);
  dest.W = load(i7);
}

command<4> FillCmd_GatherTest(u32 _, u32 dataAddress)
{
  u32 rdram = dataAddress;
  dma_in(ADDRESS_BUFFER, rdram, TILE_NUM_BYTES);
  vec16 values;
  vec16 addr;
  
  u32 counter=32;
  u32 dmemAddressSource = ADDRESS_BUFFER;
  u32 dmemDest = TILE_BUFFER;
  
  vec16 ofs = load(ADDRESS_OFFSET_VECTOR);
  
  u32 baseAddress = load(TEXTURE_BASE_ADDRESS);
  printf("texture base address: 0x%x\n", baseAddress);

  // vec32 = base, offset
  // actually we have only 12-bit offsets possible
  // --> 64k textures? assume word alignment --> 128k
  // 128k bytes = 181x181 RGB555 texture
  // maps to 32 4k textures, maybe enough for a scene?
  // still need a "base" address for DMEM loads

  vec16 indexMask;
  indexMask.x = MASK_BLOCK_INDEX;
  indexMask.y = MASK_BLOCK_INDEX;
  indexMask.z = MASK_BLOCK_INDEX;
  indexMask.w = MASK_BLOCK_INDEX;
  indexMask.X = MASK_BLOCK_INDEX;
  indexMask.Y = MASK_BLOCK_INDEX;
  indexMask.Z = MASK_BLOCK_INDEX;
  indexMask.W = MASK_BLOCK_INDEX;
  
  vec16 activeIndex;
  {
    u16 ind = load(TEX_ACTIVE_BLOCK_INDEX);
    activeIndex.x = ind;
    activeIndex.y = ind;
    activeIndex.z = ind;
    activeIndex.w = ind;
    activeIndex.X = ind;
    activeIndex.Y = ind;
    activeIndex.Z = ind;
    activeIndex.W = ind;
  }
  
  vec16 newValues;

  while (counter > 0) {
    u32 lanesLoaded = 0xffffff00;
    values = load(CONSTANT_COLOR_BLUE);
    
    //printf("counter: %v\n", counter);
    addr:sint = load(dmemAddressSource);
    //printf("dmemAddressSource: %v, addr1: %v\n", dmemAddressSource, addr);
    u16 test = addr.x;
    printf("addr.x = 0x%x\n", test);
    vec16 blockInds;
    blockInds = addr & indexMask;
    {
      vec16 unused = blockInds == activeIndex;
    }
    u32 vcc = get_vcc();
    vcc &= 0x0f;
    printf("addr: %v\nblck: %v\n", addr, blockInds);
    printf("resident vcc: 0x%x\n", vcc);
    //printf("blck: 0x%x\n", blockInds);
    
    lanesLoaded |= vcc;

    if (vcc != 0) {
      addr:sint = addr:sint + ofs:sint;
      
      @Barrier("values") gather8(newValues, addr);
      printf("newValues: %v\n", newValues);
      printf("values1:   %v\n", values);
      @Barrier("values") values = select(newValues, values);
      printf("values2:   %v\n", values); // FIXME breaks without this print
      
      // find the next block
      // 
      u32 lanesInProgress = ~lanesLoaded;
      printf("loaded: 0x%x, in progress: 0x%x\n", lanesLoaded, lanesInProgress);
      u16 bitsLeft=8;
      while (bitsLeft > 0) {
        u32 wip=lanesInProgress & 1;
        if (wip) {
          // TODO load a new block
        }
        bitsLeft = bitsLeft - 1;
      }
      
    } else {
      // current block contains no valid addresses
      values = load(CONSTANT_COLOR_RED);
    }
    
    // if (vcc == 0x0f) {
    //   values = load(CONSTANT_COLOR_GREEN);
    // }
    
    @Barrier("values") store(values, dmemDest);
    dmemAddressSource = dmemAddressSource + 16;
    dmemDest = dmemDest + 16;
    counter = counter - 1;
    //printf("ofs:  %v\n", ofs);
    //printf("addr: %v\n", addr);
    
    // We wish to check if any offset is greater than what we have stored.
    // Actually, we could just round the offset and compare high bits?
    // That way we can find any invalid page.
    // Problem: We can have at worst 8 different pages! Hard to do
    // in parallel.
    
    // Bits
    //   PAGE is 4 bits v LSB (actually 7)
    //   fedcba9876543210
    //       DRAM_ADDRESS is 12 bits (actually 9)
    
    // We wish to keep track of
    // - which lanes can be sampled right now
    // - which lanes have been filled already
    // then 
    // 1. check if any lanes can be sampled
    //    this means checking pages==resident, this sets vcc
    // 2. if we can sample pages, do a gather
    //    Question: does it make sense to gather if only some are
    //              present? a loop would take
    //              rightshift + and + branch + load. 3 instr per
    //              lane. so not a clear win over regular gather
    //              + vmrg.
    //     so gather returns garbage in some lanes, but we'll vmrg
    //     only the valid ones to 'result' vector.
    //  3. check if vcc&0xf == 0xf, if true, we are done
    //  4. otherwise, use a loop to find which vcc value was zero.
    //     that is the lane which couldn't be read from memory.
    //  5. extract the new page address
    //  6. fetch the page from RDRAM. update current page id
    //  7. go to step 1

  }
}

command<5> FillCmd_LoadTexture(u32 _, u32 dataAddress)
{
  u32 rdram = dataAddress;
  store(rdram, TEXTURE_BASE_ADDRESS);
  
  u32 block = rdram & MASK_BLOCK_INDEX;
  store(block, TEX_ACTIVE_BLOCK_INDEX);

  dma_in(TEXTURE_BUFFER, rdram, TEX_NUM_BYTES);
  vec16 ofs;
  u16 from = TEXTURE_BUFFER;
  ofs.x = from; // FIXME easier way to construct a constant offset?
  ofs.y = from;
  ofs.z = from;
  ofs.w = from;
  ofs.X = from;
  ofs.Y = from;
  ofs.Z = from;
  ofs.W = from;
  store(ofs, ADDRESS_OFFSET_VECTOR);
}

command<6> FillCmd_StoreTile(u32 _, u32 dataAddress)
{
  u32 rdram = dataAddress;
  dma_out(TILE_BUFFER, rdram, TILE_NUM_BYTES);
}

command<7> FillCmd_StoreTexture(u32 _, u32 dataAddress)
{
  u32 rdram = dataAddress;
  dma_out(TEXTURE_BUFFER, rdram, TEX_NUM_BYTES);
}
